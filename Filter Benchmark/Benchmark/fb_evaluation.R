library(ggplot2)
library(data.table)
library(mco)

# generated by fb_tuning.R
load("results_tuning.RData")

# generated in fb_rank_cors.R
load("mean_cor.RData")


# make the minimum 0
s0 = function(x) {
  return(x - min(x, na.rm = TRUE))
}


# symbols for plotting
n.methods = length(unique(results.tuned.all$fw.method))
syms.basic = c(0:2, 4:6, 8, 11, 13, 14, 17)
syms = rep(syms.basic, ceiling(n.methods / length(syms.basic)))


# consider accuracy instead of mmce
results.tuned.aggr.all[, acc.test.mean := 1 - mmce.test.mean]
results.tuned.aggr.filter[, acc.test.mean := 1 - mmce.test.mean]
results.tuned.all[, acc.test := 1 - mmce.test]
results.tuned.filter[, acc.test := 1 - mmce.test]

##########################################################################################
# mmce and time per dataset

scaleFUN = function(x) {
  sprintf("%.4f", x)
}

pdf("acc_time_filter_dataset.pdf", width = 8.25, height = 10)
gg = ggplot(data = results.tuned.aggr.filter,
  mapping = aes(x = acc.test.mean, y = timetrain.filter.test.median, color = fw.method, shape = fw.method)) +
  theme_bw() +
  geom_point(size = 2, stroke = 1) +
  facet_wrap("prob.name", nrow = 4, scales = "free") +
  scale_shape_manual(values = syms, guide = guide_legend(ncol = 3), name = "Filter Method") +
  scale_color_discrete(name = "Filter Method") +
  theme(legend.position = "bottom",
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 11),
    legend.text = element_text(size = 11),
    legend.title = element_text(size = 11),
    strip.text = element_text(size = 11),
    legend.spacing.x = unit(2, "line"),
    plot.margin = unit(c(5.5, 8.5, 5.5, 2.5), "pt")) +
  ylab("Median Run Time for Filtering (in Seconds)") +
  xlab("Mean Classification Accuracy") +
  scale_x_continuous(labels = scaleFUN, breaks = scales::pretty_breaks(n = 4))
print(gg)
dev.off()

pdf("acc_time_all_dataset.pdf", width = 8.25, height = 10)
gg = ggplot(data = results.tuned.aggr.all,
  mapping = aes(x = acc.test.mean, y = timetrain.test.median, color = fw.method, shape = fw.method)) +
  theme_bw() +
  geom_point(size = 2, stroke = 1) +
  facet_wrap("prob.name", nrow = 4, scales = "free") +
  scale_shape_manual(values = syms, guide = guide_legend(ncol = 3), name = "Filter Method") +
  scale_color_discrete(name = "Filter Method") +
  theme(legend.position = "bottom",
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 11),
    legend.text = element_text(size = 11),
    legend.title = element_text(size = 11),
    strip.text = element_text(size = 11),
    legend.spacing.x = unit(2, "line"),
    plot.margin = unit(c(5.5, 8.5, 5.5, 2.5), "pt")) +
  ylab("Median Entire Run Time (in Seconds)") +
  xlab("Mean Classification Accuracy") +
  scale_x_continuous(labels = scaleFUN, breaks = scales::pretty_breaks(n = 4))
print(gg)
dev.off()


#########################################################################################
# accs only

res.tuned = results.tuned.all
o = mean.cor$o
names.o = c(colnames(mean.cor$mean.cors)[o], "none")
res.tuned$fw.method = droplevels(factor(res.tuned$fw.method, levels = names.o))

rts = split(res.tuned, res.tuned$prob.name)
pdf("accs.pdf", width = 6, height = 5)
for (rtsi in rts) {
  gg = ggplot(data = rtsi,
    mapping = aes(y = acc.test, x = fw.method)) +
    theme_bw() +
    geom_boxplot() +
    labs(title = rtsi$prob.name[1]) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
      axis.text = element_text(size = 13),
      axis.title = element_text(size = 13.5),
      plot.title = element_text(size = 13)) +
    xlab("Filter Method") +
    ylab("Classification Accuracy")
  print(gg)
}
dev.off()

##########################################################################
# aggregate over datasets

# differences in accuracy to best methods per data set:
# irrelevant if acc or mmce is considered


# runtimes of 0: add small constant to all median runtimes
results.tuned.aggr.all2 = results.tuned.aggr.all
results.tuned.aggr.filter2 = results.tuned.aggr.filter
results.tuned.aggr.all2$timetrain.test.median = results.tuned.aggr.all$timetrain.test.median + 1e-2
results.tuned.aggr.filter2$timetrain.filter.test.median = results.tuned.aggr.filter$timetrain.filter.test.median + 1e-2


# entire run time
rfs.all = results.tuned.aggr.all2[, list(
  mmce.test.mean = s0(mmce.test.mean),
  log.timetrain.test.median = s0(log10(timetrain.test.median)),
  fw.method = fw.method),
  by = "prob.name"]

rfs.all.aggr = rfs.all[, list(
  mmce.median = median(mmce.test.mean),
  mmce.q25 = quantile(mmce.test.mean, 0.25, type = 2),
  mmce.q75 = quantile(mmce.test.mean, 0.75, type = 2),
  log.time.median = median(log.timetrain.test.median),
  log.time.q25 = quantile(log.timetrain.test.median, 0.25, type = 2),
  log.time.q75 = quantile(log.timetrain.test.median, 0.75, type = 2)
), by = "fw.method"]

gg.po.fun = function(dat, ylab.text) {
  gg = ggplot(data = dat,
    mapping = aes(x = mmce.median, y = log.time.median, color = fw.method, shape = fw.method)) +
    theme_bw() +
    geom_errorbar(aes(ymin = log.time.q25, ymax = log.time.q75), size = 0.5) +
    geom_errorbarh(aes(xmin = mmce.q25, xmax = mmce.q75), size = 0.5) +
    geom_point(size = 3, stroke = 1.5) +
    scale_shape_manual(values = syms, name = "Filter Method",
      guide = guide_legend(ncol = 1)) +
    scale_color_discrete(drop = FALSE, name = "Filter Method") +
    xlab("Relative Mean Classification Accuracy") +
    ylab(ylab.text) +
    theme(axis.text = element_text(size = 12),
      axis.title = element_text(size = 12.5),
      legend.text = element_text(size = 12),
      legend.title = element_text(size = 12))
  return(gg)
}

pdf("acc_time_all.pdf", width = 7, height = 6)
gg = gg.po.fun(rfs.all.aggr, "Relative Logarithmic Median Entire Run Time")
print(gg)
dev.off()

# Pareto optimal
x1 = paretoFilter(as.matrix(rfs.all.aggr[, c("mmce.median", "log.time.median")]))
merge(x1, rfs.all.aggr)

x2 = paretoFilter(as.matrix(rfs.all.aggr[, c("mmce.q75", "log.time.q75")]))
merge(x2, rfs.all.aggr)


# run time for filtering
rfs.filter = results.tuned.aggr.filter2[, list(
  mmce.test.mean = s0(mmce.test.mean),
  log.timetrain.filter.test.median = s0(log10(timetrain.filter.test.median)),
  fw.method = fw.method),
  by = "prob.name"]

rfs.filter.aggr = rfs.filter[, list(
  mmce.median = median(mmce.test.mean),
  mmce.q25 = quantile(mmce.test.mean, 0.25, type = 2),
  mmce.q75 = quantile(mmce.test.mean, 0.75, type = 2),
  log.time.median = median(log.timetrain.filter.test.median),
  log.time.q25 = quantile(log.timetrain.filter.test.median, 0.25, type = 2),
  log.time.q75 = quantile(log.timetrain.filter.test.median, 0.75, type = 2)
), by = "fw.method"]

pdf("acc_time_filter.pdf", width = 7, height = 6)
gg = gg.po.fun(rfs.filter.aggr, "Relative Logarithmic Median Run Time for Filtering")
print(gg)
dev.off()

# Pareto optimal
x3 = paretoFilter(as.matrix(rfs.filter.aggr[, c("mmce.median", "log.time.median")]))
merge(x3, rfs.filter.aggr)

x4 = paretoFilter(as.matrix(rfs.filter.aggr[, c("mmce.q75", "log.time.q75")]))
merge(x4, rfs.filter.aggr)



############################################################################

dominated = function(x1, x2) {
  (x1 < x2) + 0.5 * (x1 == x2)
}

dom.matrix = function(mmce) {
  mat = matrix(0L, ncol = n.methods, nrow = n.methods)
  for (i in 1:n.methods) {
    for (j in setdiff(1:n.methods, i)) {
      mat[i, j] = dominated(mmce[i], mmce[j])
    }
  }
  return(mat)
}

domin = results.tuned.aggr.all[, list(dom.mat = list(dom.matrix(mmce.test.mean))), by = c("prob.name")]

dom.mats = domin$dom.mat
n.dominated = dom.mats[[1]]
for (i in 2:12) {
  n.dominated = n.dominated + dom.mats[[i]]
}

rownames(n.dominated) = colnames(n.dominated) = results.tuned.aggr.all[prob.name == "sonar", ]$fw.method

times.d = data.frame(dominating = rowSums(n.dominated), dominated = colSums(n.dominated))
o = order(times.d$dominating, decreasing = TRUE)
times.d = times.d[o, ]

plot_mat2 = function(dat, names, title = "") {
  colnames(dat) = rownames(dat) = names
  plt.data = cbind(measure = names, as.data.frame(dat))
  plt.data = reshape2::melt(plt.data, id.vars = "measure")
  plt.data$measure = factor(plt.data$measure, levels = names)
  plt.data$variable = factor(plt.data$variable, levels = names)

  gg = ggplot(plt.data, aes(measure, variable)) +
    geom_tile(aes(fill = value), colour = "white") +
    scale_fill_gradient2(low = "darkblue", mid = "white", high = "darkred", name = "Times",
      limits = c(0, 12), midpoint = 6) +
    geom_text(aes(label = value, color = abs(value - 6) >= 3.5), size = 5) +
    scale_color_manual(guide = FALSE, values = c("black", "white")) +
    theme_grey() +
    labs(x = "", y = "", title = title) +
    scale_x_discrete(expand = c(0, 0), labels = names) +
    scale_y_discrete(expand = c(0, 0), labels = names) +
    theme(axis.ticks = element_blank()) +
    coord_equal(ratio = 0.5) +
    xlab("Losses") +
    ylab("Wins") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
      axis.text = element_text(size = 13),
      axis.title = element_text(size = 13),
      legend.text = element_text(size = 12),
      legend.title = element_text(size = 13))

  print(gg)
  invisible(NULL)
}

dom.n = names(sort(rowSums(n.dominated), decreasing = FALSE))
dom.o = n.dominated[dom.n, dom.n]
diag(dom.o) = NA

pdf("better_accuracy.pdf", width = 11, height = 6)
plot_mat2(t(dom.o), dom.n)
dev.off()
